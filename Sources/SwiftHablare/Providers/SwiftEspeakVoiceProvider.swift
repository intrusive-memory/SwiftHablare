//
//  SwiftEspeakVoiceProvider.swift
//  SwiftHablare
//
//  SwiftEspeak implementation of VoiceProvider
//

import Foundation

#if canImport(SwiftEspeak)
import SwiftEspeak

/// Voice provider backed by the SwiftEspeak package.
///
/// This provider uses the eSpeak speech synthesis engine through the
/// SwiftEspeak Swift Package. Audio is generated by asking SwiftEspeak to
/// render a temporary WAV file which is then returned as `Data`.
public final class SwiftEspeakVoiceProvider: VoiceProvider {
    public let providerId = "swift-espeak"
    public let displayName = "SwiftEspeak"
    public let requiresAPIKey = false

    private let synthesizer: SwiftEspeak?
    private let workQueue = DispatchQueue(label: "SwiftEspeakVoiceProvider.WorkQueue")

    public init() {
        self.synthesizer = try? SwiftEspeak()
    }

    public func isConfigured() -> Bool {
        return synthesizer != nil
    }

    public func fetchVoices(languageCode: String) async throws -> [Voice] {
        guard let synthesizer else {
            throw VoiceProviderError.notConfigured
        }

        return try await withCheckedThrowingContinuation { continuation in
            workQueue.async {
                do {
                    let voices: [SwiftEspeakVoice]
                    if languageCode.isEmpty {
                        voices = try synthesizer.listVoices()
                    } else {
                        voices = try synthesizer.listVoices(language: languageCode)
                    }

                    let mapped = voices.map { voice in
                        voice.toSwiftHablareVoice(providerId: self.providerId)
                    }
                    continuation.resume(returning: mapped)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    public func generateAudio(text: String, voiceId: String, languageCode: String) async throws -> Data {
        guard let synthesizer else {
            throw VoiceProviderError.notConfigured
        }

        guard !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw VoiceProviderError.invalidRequest("Text cannot be empty")
        }

        return try await withCheckedThrowingContinuation { continuation in
            workQueue.async {
                do {
                    if !voiceId.isEmpty {
                        try synthesizer.setVoice(voiceId)
                    }

                    let fileManager = FileManager.default
                    let tempDirectory = fileManager.temporaryDirectory
                    let filename = "swift-espeak-\(UUID().uuidString).wav"
                    let outputURL = tempDirectory.appendingPathComponent(filename)

                    defer {
                        try? fileManager.removeItem(at: outputURL)
                    }

                    try synthesizer.generateAudioFile(
                        text: text,
                        outputPath: outputURL.path,
                        voice: voiceId.isEmpty ? nil : voiceId
                    )

                    let data = try Data(contentsOf: outputURL)
                    continuation.resume(returning: data)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    public func estimateDuration(text: String, voiceId: String) async -> TimeInterval {
        // Use a conservative estimate of 170 words per minute (eSpeak default ~175).
        let words = Double(text.split { $0.isWhitespace || $0.isNewline }.count)
        let wordsPerMinute = 170.0
        let minutes = words / wordsPerMinute
        let seconds = minutes * 60.0

        // Add small buffer for pauses.
        return max(1.0, seconds * 1.1)
    }

    public func isVoiceAvailable(voiceId: String) async -> Bool {
        guard let synthesizer, !voiceId.isEmpty else {
            return false
        }

        return await withCheckedContinuation { continuation in
            workQueue.async {
                do {
                    let voices = try synthesizer.listVoices()
                    continuation.resume(returning: voices.contains { voice in
                        voice.matchesIdentifier(voiceId)
                    })
                } catch {
                    continuation.resume(returning: false)
                }
            }
        }
    }
}

private extension SwiftEspeakVoice {
    func matchesIdentifier(_ identifier: String) -> Bool {
        if let voiceIdentifier = self.identifier, voiceIdentifier == identifier {
            return true
        }

        return name == identifier
    }

    func toSwiftHablareVoice(providerId: String) -> Voice {
        var descriptionComponents: [String] = []

        if let variant = variant, !variant.isEmpty {
            descriptionComponents.append(variant)
        }

        if let gender = gender, !gender.isEmpty {
            descriptionComponents.append(gender)
        }

        if let age = age {
            descriptionComponents.append("Age \(age)")
        }

        let description = descriptionComponents.isEmpty ? nil : descriptionComponents.joined(separator: ", ")

        return Voice(
            id: identifier ?? name,
            name: name,
            description: description,
            providerId: providerId,
            language: language,
            locality: variant,
            gender: gender
        )
    }
}

#else

/// Fallback SwiftEspeak provider used when the SwiftEspeak package is not
/// available at compile time. The provider reports itself as not configured
/// and throws `VoiceProviderError.notSupported` for runtime operations.
public final class SwiftEspeakVoiceProvider: VoiceProvider {
    public let providerId = "swift-espeak"
    public let displayName = "SwiftEspeak"
    public let requiresAPIKey = false

    public init() {}

    public func isConfigured() -> Bool {
        return false
    }

    public func fetchVoices(languageCode: String) async throws -> [Voice] {
        throw VoiceProviderError.notSupported
    }

    public func generateAudio(text: String, voiceId: String, languageCode: String) async throws -> Data {
        throw VoiceProviderError.notSupported
    }

    public func estimateDuration(text: String, voiceId: String) async -> TimeInterval {
        return 0
    }

    public func isVoiceAvailable(voiceId: String) async -> Bool {
        return false
    }
}

#endif
